# -*- coding: utf-8 -*-
"""
Created on Thu Sep 17 17:50:14 2020

@author: martinchen
"""

from absl import flags
import cv2
import numpy as np
from object_detection.utils import config_util
from object_detection.builders import model_builder
import os
import pandas as pd
import re
import shutil
import tensorflow as tf
import time
import xml.etree.cElementTree as ET
from xml.dom import minidom



flags.DEFINE_string('model_dir', None, 'Path to output model directory '
                    'where event and checkpoint files will be written.')
flags.DEFINE_string('pipeline_config_path', None, 'Path to pipeline config '
                    'file.')
flags.DEFINE_string('input_dir', None, 'Path to input directory')
flags.DEFINE_string('IOU_threshold', '0.7', 'The IOU threshold used to determine the confidence score threshold of each object during automatic labeling')

FLAGS = flags.FLAGS


def set_parameter():
    global IMG_EXT, MODEL_PATH
    IMG_EXT = ['jpeg','JPEG','jpg','JPG','png','PNG','bmp','BMP','tif','TIF','tiff','TIFF']
    with open(os.path.join(FLAGS.model_dir, 'checkpoint'), 'r') as f:
        first_line = f.readline()
    MODEL_PATH = os.path.join(FLAGS.model_dir, first_line.split('\"')[1])
    
    
    
    global PBTXT_PATH, TRAIN_IMG_DIR, TRAIN_XML_DIR, EVAL_IMG_DIR, EVAL_XML_DIR, UNLABELED_IMG_DIR, UNLABELED_XML_DIR
    PBTXT_PATH = os.path.join(FLAGS.input_dir, '4_setting', 'pascal_label_map.pbtxt')
    TRAIN_IMG_DIR = os.path.join(FLAGS.input_dir, '1_train_data', 'img')
    TRAIN_XML_DIR = os.path.join(FLAGS.input_dir, '1_train_data', 'xml')
    EVAL_IMG_DIR = os.path.join(FLAGS.input_dir, '2_eval_data', 'img')
    EVAL_XML_DIR = os.path.join(FLAGS.input_dir, '2_eval_data', 'xml')
    UNLABELED_IMG_DIR = os.path.join(FLAGS.input_dir, '3_unlabeled_data', 'img')
    
    time_ = time.strftime("%Y%m%d_%H%M", time.localtime())
    UNLABELED_XML_DIR = os.path.join(FLAGS.input_dir, '3_unlabeled_data', 'xml', time_)
    if not os.path.isdir(UNLABELED_XML_DIR):
        os.makedirs(UNLABELED_XML_DIR)


def get_model_detection_function(model):
  """Get a tf.function for detection."""

  @tf.function
  def detect_fn(image):
    """Detect objects in image."""

    image, shapes = model.preprocess(image)
    prediction_dict = model.predict(image, shapes)
    detections = model.postprocess(prediction_dict, shapes)

    return detections, prediction_dict, tf.reshape(shapes, [-1])

  return detect_fn

def parse_pbtxt(pbtxt):
    """Parse pbtxt file and create dictionary record object and its id.
    Args:
        pbtxt: str, full path to pbtxt file
        
    Returns:
        pbtxt_dict: dict, {object1_id: object1_type, object2_id ...}, dictionary record object and its id
    """
    pbtxt_dict = {}
    with open(pbtxt, 'r') as f:
        key_ = None; value_ = None
        for line in f:
            if '}' in line:
                # pbtxt start from 1 but object type in result_classes start from 0
                pbtxt_dict[int(key_) - 1] = value_
                key_ = None
                value_ = None
                search = False
            if 'item' in line:
                search = True
            if search and ('name' in line):
                value_ = line.split(':')[-1]
                value_ = re.search(r'[a-zA-Z0-9_-]+', value_).group(0)
            if search and ('id' in line):
                key_ = line.split(':')[-1]
                key_ = re.search(r'[0-9]+', key_).group(0)
    return pbtxt_dict
    

def predict_img(img, detect_fn):
    input_tensor = tf.convert_to_tensor(np.expand_dims(img, 0), dtype=tf.float32)
    detections, predictions_dict, shapes = detect_fn(input_tensor)
    num_detections = int(detections.pop('num_detections'))
    detections = {key:value[0, :num_detections].numpy() 
                  for key,value in detections.items()}
    return detections['detection_boxes'], detections['detection_scores'], detections['detection_classes'], num_detections


def get_real_coordinate(box, img_height, img_width):
    """Convert the standardized coordinates generated by the model into real coordinates corresponding to the image size.
    Args:
        box: numpy.ndarray, [ymin xmin ymax xmax]
        
    Returns:
        ymin, xmin, ymax, xmax: float, real coordinates corresponding to the image size.
    """
    ymin, xmin, ymax, xmax = box
    ymin *= img_height
    xmin *= img_width
    ymax *= img_height
    xmax *= img_width
    
    return ymin, xmin, ymax, xmax

def cal_IOU(coordinate1, coordinate2):
    """Calculate the IOU value of the two box
    Args:
      coordinate1, coordinate2: tuple, (ymin, xmin, ymax, xmax)
      
    Returns:
      float, IOU value of the two box
    
    """
    ymin1, xmin1, ymax1, xmax1 = coordinate1
    ymin2, xmin2, ymax2, xmax2 = coordinate2
    
    area1 = (xmax1 - xmin1) * (ymax1 - ymin1)
    area2 = (xmax2 - xmin2) * (ymax2 - ymin2)
    
    inter_ymin = max(ymin1, ymin2)
    inter_xmin = max(xmin1, xmin2)
    inter_ymax = min(ymax1, ymax2)
    inter_xmax = min(xmax1, xmax2)
    w = max(0, inter_xmax - inter_xmin)
    h = max(0, inter_ymax - inter_ymin)
    inter_area = w * h

    IOU = inter_area / (area1 + area2 - inter_area)
    return IOU


def generate_df(detect_fn, pbtxt_dict):
    """Generate dataframe that record object_type, IOU, score for each predicted object
    Args:
        detect_fu: detection function from ckpt
        pbtxt_dict: dict, {object1_id: object1_type, object2_id ...}, dictionary record object and its id
    
    Returns:
        object_df: DataFrame, [Index, object_type, IOU, score], record information for each predicted object
    
    """
    def parse_xml(xml_path):
        # parse all objects in xml
        tree = ET.parse(xml_path)
        tree_root = tree.getroot()
        bndbox_infor = tree_root.findall('./object')
        return bndbox_infor
    
    column_names = ['object_type', 'IOU', 'score']
    object_df = pd.DataFrame(columns = column_names)
    # Loop through all evaluation images
    for root, dirs, files in os.walk(EVAL_IMG_DIR):
        for file in files:
            # check whether the file is image 
            if file.endswith(tuple(IMG_EXT)):
                xml_file = file.split('.')[0] + '.xml'
                bndbox_infor = parse_xml(os.path.join(EVAL_XML_DIR, xml_file))
                img = cv2.imread(os.path.join(root, file), 1)
                img_height, img_width, img_channel = img.shape
                if img_channel == 3:
                    img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
                result_boxes, result_scores, result_classes, result_num_detections = predict_img(img, detect_fn)
                

                # Loop through all predicted objects
                for i in range(result_num_detections):
                    pred_object_type = pbtxt_dict[int(result_classes[i])]
                    pred_score = result_scores[i]
                    pred_ymin, pred_xmin, pred_ymax, pred_xmax = get_real_coordinate(result_boxes[i], img_height, img_width)
                    max_IOU = 0
                    # Loop through all objects in xml
                    for i in range(len(bndbox_infor)):
                        GT_object_type = bndbox_infor[i].find('./name').text
                        GT_ymin = int(bndbox_infor[i].find('./bndbox/ymin').text)
                        GT_xmin = int(bndbox_infor[i].find('./bndbox/xmin').text)
                        GT_ymax = int(bndbox_infor[i].find('./bndbox/ymax').text)
                        GT_xmax = int(bndbox_infor[i].find('./bndbox/xmax').text)
                        
                        if pred_object_type == GT_object_type:
                            IOU = cal_IOU((GT_ymin, GT_xmin, GT_ymax, GT_xmax), (pred_ymin, pred_xmin, pred_ymax, pred_xmax))
                            if IOU > max_IOU:
                                max_IOU = IOU
                                
                    new_row = pd.DataFrame({'object_type':pred_object_type, 'IOU':max_IOU, 'score':pred_score}, index=[i])
                    object_df = object_df.append(new_row,ignore_index=True)
                    
    return object_df
    
def get_threshold(object_df, pbtxt_dict, IOU_threshold):
    """Get the threshold of score that makes the IOU of each object greater than IOU_threshold
    Args:
        object_df: DataFrame, [Index, object_type, IOU, score], record information for each predicted object
        pbtxt_dict: dict, {object1_id: object1_type, object2_id ...}, dictionary record object and its id
        IOU_threshold: float, IOU threshold for automatic labeling
        
    Returns:
        threshold_dict: dict, {object1_type: threshold1, object2_type ...}, dictionary record object and its threshold.
    """
    
    threshold_dict = {}
    
    for key, value in pbtxt_dict.items():
        type_filter = object_df['object_type'] == value
        target_df = object_df[type_filter]
        target_df = target_df.sort_values(by=['IOU'], ascending=False, ignore_index=True)
        IOU_filter = (target_df['IOU'] >= IOU_threshold)
        
        horizon = len(target_df[IOU_filter])
        temp = target_df[horizon-5:horizon+5]['score']
        temp = temp[temp>0.5]
        threshold = temp.mean()
        threshold_dict[value] = threshold
    return threshold_dict


def generate_xml(boxes, classes, num_object, img_height, img_width, img_channel, img_filename, pbtxt_dict, img_folder = 'image_folder', img_dir = r'D:\image_path'):
    """Generate the xml file of the predicted image.
    Args:
      boxes: numpy.ndarray, contains predicted boxes coordinates ([[xmin1 ymin1 xmax1 ymax1], [xmin2 ymin2 xmax2 ymax2], ....])
      classes: numpy.ndarray, predicted classes of each object, ([class1 class2 class3 ...])
      num_object: int, number of objects should be recorded in xml
      img_height, img_width, img_channel: int, image information
      img_filename: str, name of predicted image.
      pbtxt_dict: dict, {object1_id: object1_type, object2_id ...}, dictionary record object and its id
      img_folder, img_dir: str, information recorded in xml
      
    """
    def create_subElement(root, name, content):
        """Create sub-element with content"""
        sub_element = doc.createElement(name)
        root.appendChild(sub_element)
        sub_content = doc.createTextNode(content)
        sub_element.appendChild(sub_content)
    
        return root
    
    def create_subElement_1(root, name):
        """Create sub-element with sub-element inside"""
        sub_element = doc.createElement(name)
        root.appendChild(sub_element)
    
        return root, sub_element
    
    def create_basic_infor(doc, img_folder, img_filename, img_dir):
        """Create part of the basic information in xml"""
        tree = doc.createElement('annotation')
        doc.appendChild(tree)
        
        tree = create_subElement(tree, 'folder', img_folder)
        tree = create_subElement(tree, 'filename', img_filename)
        tree = create_subElement(tree, 'path', img_dir)
        
        tree, source = create_subElement_1(tree, 'source')
        source = create_subElement(source, 'database', 'Unknown')
        
        tree, size = create_subElement_1(tree, 'size')
        size = create_subElement(size, 'width', str(img_width))
        size = create_subElement(size, 'height', str(img_height))
        size = create_subElement(size, 'depth', str(img_channel))
        
        tree = create_subElement(tree, 'segmented', '0')
        
        
        return doc, tree
    
    def create_object(root, name, pose, truncated, difficult, xmin, ymin, xmax, ymax):
        """Create object information in xml"""
        element_object = doc.createElement('object')
        root.appendChild(element_object)
        
        element_object = create_subElement(element_object, 'name', name)
        element_object = create_subElement(element_object, 'pose', pose)
        element_object = create_subElement(element_object, 'truncated', truncated)
        element_object = create_subElement(element_object, 'difficult', difficult)
        
        element_object, object_bndbox = create_subElement_1(element_object, 'bndbox')
        object_bndbox = create_subElement(object_bndbox, 'xmin', xmin)
        object_bndbox = create_subElement(object_bndbox, 'ymin', ymin)
        object_bndbox = create_subElement(object_bndbox, 'xmax', xmax)
        object_bndbox = create_subElement(object_bndbox, 'ymax', ymax)
        
        return root, element_object
    
        
    xml_file = os.path.join(UNLABELED_XML_DIR, img_filename.split('.')[0]+'.xml')
    # Create xml file with basic information
    doc = minidom.Document()
    doc, tree = create_basic_infor(doc, img_folder, img_filename, img_dir)
    
    for i in range(num_object):
        y_min, x_min, y_max, x_max = get_real_coordinate(boxes[i], img_height, img_width)
        y_min, x_min, y_max, x_max = int(y_min), int(x_min), int(y_max), int(x_max)
        object_type = pbtxt_dict[int(classes[i])]

        # Add object information
        tree, object_ = create_object(tree, object_type, 'Unspecified', '0', '0', str(x_min), str(y_min), str(x_max), str(y_max))
        
        
    f = open(xml_file, 'w')
    f.write(doc.toprettyxml(indent='\t', newl = '\n'))
    f.close()
        


def main(_):
    set_parameter()
    # Load config and build model
    print('Loading config...')
    configs = config_util.get_configs_from_pipeline_file(FLAGS.pipeline_config_path)
    model_config = configs['model']
    detection_model = model_builder.build(
    model_config=model_config, is_training=False)
    # Restore checkpoint
    print('Restoring checkpoint...')
    ckpt = tf.compat.v2.train.Checkpoint(model=detection_model)
    ckpt.restore(MODEL_PATH).expect_partial()
    detect_fn = get_model_detection_function(detection_model)
    
    # Parse pbtxt file
    print('Parsing pbtxt...')
    pbtxt_dict = parse_pbtxt(PBTXT_PATH)
    # Generate dataframe that record object_type, IOU, score for each predicted object
    print('Creating object dataframe...')
    object_df = generate_df(detect_fn, pbtxt_dict)
    # Get the threshold of score that makes the IOU of each object greater than FLAGS.IOU_threshold
    print('Getting threshold...')
    threshold_dict = get_threshold(object_df, pbtxt_dict, float(FLAGS.IOU_threshold))
    
    # Filter some elements that should not be considered
    low_score_threshold = 0.2 
    # Loop through all unlabel image
    print('Labeling automatically...')
    for root, dirs, files in os.walk(UNLABELED_IMG_DIR):
        for file in files:
            if file.endswith(tuple(IMG_EXT)):
                img = cv2.imread(os.path.join(root, file), 1)
                img_height, img_width, img_channel = img.shape
                if img_channel == 3:
                    img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
                result_boxes, result_scores, result_classes, result_num_detections = predict_img(img, detect_fn)
                move_flag = False
                # Loop through all predicted objects
                for i in range(result_num_detections):
                    pred_object_type = pbtxt_dict[int(result_classes[i])]
                    # Since max_detections_per_class in config may greater than number of object, it will generate some predicted boxes that score close to zero
                    if result_scores[i] < threshold_dict[pred_object_type] and result_scores[i] > low_score_threshold:
                        move_flag = False
                        break
                    elif result_scores[i] >= threshold_dict[pred_object_type]:
                        move_flag = True
                        
                # Generate xml and move images and xml to training data folder
                if move_flag:
                    xml_file = file.split('.')[0] + '.xml'
                    num_object = len(result_scores[result_scores >= low_score_threshold])
                    generate_xml(result_boxes, result_classes, num_object, img_height, img_width, img_channel, file, pbtxt_dict)
                    shutil.copy2(os.path.join(UNLABELED_IMG_DIR, file), os.path.join(TRAIN_IMG_DIR, file))
                    shutil.copy2(os.path.join(UNLABELED_XML_DIR, xml_file), os.path.join(TRAIN_XML_DIR, xml_file))
                    
if __name__ == '__main__':
    tf.compat.v1.app.run()
